---
import Layout from '../layouts/Layout.astro';
import Header from '../components/Header.astro';
import AppCard from '../components/AppCard.astro';
import { getApps } from '../lib/db';
import { getCurrentUser, isAdmin } from '../lib/auth';
import { CATEGORY_LABELS, CATEGORY_DOT_COLORS } from '../lib/icons';

const env = Astro.locals.runtime.env;
const user = await getCurrentUser(Astro.request, env.JWT_SECRET);
const admin = isAdmin(user, env.ADMIN_GITHUB_USERNAME);

let apps = [];
try {
  apps = await getApps(env.DB);
} catch (e) {
  // DB not initialized yet - show empty state
}

const categories = Object.entries(CATEGORY_LABELS);
---
<Layout title="Web App Catalog">
  <Header user={user} />

  <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
    <div class="flex items-center justify-between mb-8">
      <div>
        <h1 class="text-2xl font-bold text-gray-900">マイアプリ一覧</h1>
        <p class="text-gray-600 mt-1">自作Webアプリのカタログ</p>
      </div>
      {admin && (
        <div class="flex items-center gap-3">
          <button
            id="edit-mode-btn"
            class="inline-flex items-center gap-2 px-4 py-2.5 text-sm font-medium rounded-lg border border-gray-300 text-gray-700 bg-white hover:bg-gray-50 transition-colors"
          >
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
            </svg>
            編集
          </button>
          <button
            id="add-app-btn"
            class="inline-flex items-center gap-2 px-4 py-2.5 bg-indigo-600 text-white text-sm font-medium rounded-lg hover:bg-indigo-700 transition-colors shadow-sm"
          >
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
            </svg>
            アプリを追加
          </button>
        </div>
      )}
    </div>

    {apps.length > 0 && (
      <div class="flex flex-wrap gap-x-4 gap-y-1 mb-6 text-xs text-gray-500">
        {categories.map(([key, label]) => (
          <span class="inline-flex items-center gap-1.5">
            <span class:list={['w-2.5 h-2.5 rounded-full', CATEGORY_DOT_COLORS[key]]} />
            {label}
          </span>
        ))}
      </div>
    )}

    {apps.length > 0 ? (
      <div id="app-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {apps.map((app) => <AppCard app={app} admin={admin} />)}
      </div>
    ) : (
      <div class="text-center py-20">
        <div class="inline-flex items-center justify-center w-16 h-16 rounded-full bg-indigo-100 mb-4">
          <svg class="w-8 h-8 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />
          </svg>
        </div>
        <h2 class="text-xl font-semibold text-gray-900 mb-2">アプリがまだありません</h2>
        <p class="text-gray-600 mb-6">
          {admin
            ? '「アプリを追加」ボタンから最初のアプリを登録しましょう'
            : 'まだアプリが登録されていません'
          }
        </p>
      </div>
    )}
  </main>

  <!-- Tech popover (shared) -->
  <div id="tech-popover" class="fixed z-50 hidden pointer-events-none">
    <div class="bg-gray-900 text-white text-xs rounded-lg px-3 py-2 shadow-lg max-w-xs pointer-events-auto">
      <div id="tech-popover-name" class="font-semibold mb-0.5"></div>
      <div id="tech-popover-role" class="text-yellow-300 mb-0.5 hidden"></div>
      <div id="tech-popover-desc" class="text-gray-300 leading-relaxed"></div>
    </div>
  </div>

  {user && (
    <div id="dialog-root"></div>
  )}
</Layout>

<script>
  // Tech badge popover
  const popover = document.getElementById('tech-popover')!;
  const popoverName = document.getElementById('tech-popover-name')!;
  const popoverRole = document.getElementById('tech-popover-role')!;
  const popoverDesc = document.getElementById('tech-popover-desc')!;

  function showPopover(badge: HTMLElement) {
    const name = badge.dataset.techName || '';
    const desc = badge.dataset.techDesc || '';
    const role = badge.dataset.techRole || '';
    if (!desc && !role) return;

    popoverName.textContent = name;
    if (role) {
      popoverRole.textContent = role;
      popoverRole.classList.remove('hidden');
    } else {
      popoverRole.classList.add('hidden');
    }
    popoverDesc.textContent = desc;
    popover.classList.remove('hidden');

    const rect = badge.getBoundingClientRect();
    const popoverRect = popover.getBoundingClientRect();

    let top = rect.bottom + 6;
    let left = rect.left + rect.width / 2 - popoverRect.width / 2;

    // Keep within viewport
    if (left < 8) left = 8;
    if (left + popoverRect.width > window.innerWidth - 8) {
      left = window.innerWidth - popoverRect.width - 8;
    }
    if (top + popoverRect.height > window.innerHeight - 8) {
      top = rect.top - popoverRect.height - 6;
    }

    popover.style.top = `${top}px`;
    popover.style.left = `${left}px`;
  }

  function hidePopover() {
    popover.classList.add('hidden');
  }

  document.addEventListener('click', (e) => {
    const badge = (e.target as HTMLElement).closest('.tech-badge') as HTMLElement | null;
    if (badge) {
      e.stopPropagation();
      const isVisible = !popover.classList.contains('hidden');
      const currentName = popoverName.textContent;
      hidePopover();
      if (!isVisible || currentName !== badge.dataset.techName) {
        showPopover(badge);
      }
    } else if (!(e.target as HTMLElement).closest('#tech-popover')) {
      hidePopover();
    }
  });
</script>

{admin && (
  <script>
    // Edit mode toggle
    const editModeBtn = document.getElementById('edit-mode-btn');
    let editMode = false;

    editModeBtn?.addEventListener('click', () => {
      editMode = !editMode;
      document.body.classList.toggle('edit-mode', editMode);

      // Show/hide edit UI elements
      document.querySelectorAll('.edit-mode-ui').forEach((el) => {
        el.classList.toggle('hidden', !editMode);
      });

      // Update button style
      if (editMode) {
        editModeBtn.classList.remove('border-gray-300', 'text-gray-700', 'bg-white', 'hover:bg-gray-50');
        editModeBtn.classList.add('border-indigo-500', 'text-indigo-700', 'bg-indigo-50', 'hover:bg-indigo-100');
      } else {
        editModeBtn.classList.remove('border-indigo-500', 'text-indigo-700', 'bg-indigo-50', 'hover:bg-indigo-100');
        editModeBtn.classList.add('border-gray-300', 'text-gray-700', 'bg-white', 'hover:bg-gray-50');
      }
    });

    // Delete handler
    document.addEventListener('click', async (e) => {
      const deleteBtn = (e.target as HTMLElement).closest('.delete-btn') as HTMLElement | null;
      if (!deleteBtn) return;
      const appId = deleteBtn.dataset.deleteAppId;
      if (!appId) return;
      if (!confirm('本当に削除しますか？')) return;

      try {
        const res = await fetch(`/api/apps?id=${appId}`, { method: 'DELETE' });
        if (res.ok) {
          location.reload();
        } else {
          alert('削除に失敗しました');
        }
      } catch {
        alert('削除に失敗しました');
      }
    });

    // Drag & Drop
    const grid = document.getElementById('app-grid');
    let draggedCard: HTMLElement | null = null;

    grid?.addEventListener('mousedown', (e) => {
      const handle = (e.target as HTMLElement).closest('.drag-handle');
      if (!handle || !editMode) return;
      const card = handle.closest('article') as HTMLElement;
      if (card) card.draggable = true;
    });

    grid?.addEventListener('dragstart', (e) => {
      const card = (e.target as HTMLElement).closest('article') as HTMLElement;
      if (!card || !editMode) return;
      draggedCard = card;
      card.style.opacity = '0.5';
      e.dataTransfer!.effectAllowed = 'move';
    });

    grid?.addEventListener('dragover', (e) => {
      e.preventDefault();
      if (!draggedCard || !editMode) return;
      e.dataTransfer!.dropEffect = 'move';

      const target = (e.target as HTMLElement).closest('article') as HTMLElement;
      if (!target || target === draggedCard) return;

      const cards = Array.from(grid!.querySelectorAll('article'));
      const draggedIdx = cards.indexOf(draggedCard);
      const targetIdx = cards.indexOf(target);

      if (draggedIdx < targetIdx) {
        target.after(draggedCard);
      } else {
        target.before(draggedCard);
      }
    });

    grid?.addEventListener('dragend', async (e) => {
      const card = (e.target as HTMLElement).closest('article') as HTMLElement;
      if (card) {
        card.style.opacity = '';
        card.draggable = false;
      }

      if (!draggedCard || !grid) {
        draggedCard = null;
        return;
      }

      // Collect new order and send to API
      const cards = Array.from(grid.querySelectorAll('article'));
      const orders = cards.map((c, i) => ({
        id: Number((c as HTMLElement).dataset.appId),
        display_order: i,
      }));

      draggedCard = null;

      try {
        await fetch('/api/apps/reorder', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ orders }),
        });
      } catch {
        // Silently fail - order will be correct on next page load from server
      }
    });

    grid?.addEventListener('drop', (e) => {
      e.preventDefault();
    });
  </script>
)}

{user && (
  <script>
    import { render, h } from 'preact';
    import AddAppDialog from '../components/AddAppDialog';

    const btn = document.getElementById('add-app-btn');
    const root = document.getElementById('dialog-root');
    let isOpen = false;

    interface EditAppData {
      id: number;
      title: string;
      description: string;
      site_url: string;
      github_url: string;
      thumbnail_url: string;
      tech_ids: number[];
    }

    function renderDialog(open: boolean, editApp?: EditAppData) {
      isOpen = open;
      if (root) {
        render(
          h(AddAppDialog, {
            isOpen: open,
            onClose: () => renderDialog(false),
            onSaved: () => { renderDialog(false); location.reload(); },
            ...(editApp ? { editApp } : {}),
          }),
          root
        );
      }
    }

    btn?.addEventListener('click', () => renderDialog(true));

    // Edit button handler
    document.addEventListener('click', (e) => {
      const editBtn = (e.target as HTMLElement).closest('.edit-btn') as HTMLElement | null;
      if (!editBtn) return;
      const data = editBtn.dataset.editApp;
      if (!data) return;
      try {
        const editApp = JSON.parse(data) as EditAppData;
        renderDialog(true, editApp);
      } catch {
        // Invalid data
      }
    });
  </script>
)}
